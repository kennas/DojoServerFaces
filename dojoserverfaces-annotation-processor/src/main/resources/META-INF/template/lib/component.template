// Generated by DojoServerFaces.
/*******************************************************************************
 * 	Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * 	Available via Academic Free License >= 2.1 OR the modified BSD license.
 * 	see: http://dojotoolkit.org/license for details
 *******************************************************************************/
package ${context.packageName};

/**
 * ${context.componentInfo.description}
 */
@javax.faces.event.ListenerFor(systemEventClass=javax.faces.event.PostAddToViewEvent.class)
public final class ${context.unqualifiedClassName}<% if(context.superclass != null) { 
%> extends ${context.superclass}<% } %>
    implements org.dojoserverfaces.widget.DojoWidget
<%if(context.interfaces.size() > 0) { %>,
     <% context.interfaces.eachWithIndex() { interfaceName, i -> %>${interfaceName} ${i <(context.interfaces.size() - 1) ? "," : ""}<% }
}
%>{

    // initialize static fields used by the widget renderer
    
    // HTML element used to render this component.
    private static final org.dojoserverfaces.widget.element.HtmlElement element =
        org.dojoserverfaces.widget.element.ElementRendererFactory.getRenderer(${componentInfo.elementType});
    
    // list of event names
    private static final java.util.LinkedList<java.lang.String> eventNames =
        new java.util.LinkedList<java.lang.String>();
    
    // list of component properties.
    private static final java.util.LinkedList<org.dojoserverfaces.widget.property.Property> propertyHandlers =
        new java.util.LinkedList<org.dojoserverfaces.widget.property.Property>();
        
    private static final String jsfNode = "${context.componentInfo.jsfNode}";

    // dojo type for this component.
    private static final org.dojoserverfaces.widget.DojoType widgetType =
<%
if (context.componentInfo.isWidget){ 
%>        new org.dojoserverfaces.widget.SimpleWidgetType("${componentInfo.dojoType}", false);  // TODO: FIX ME!!!
<%
} else { 
%>        new org.dojoserverfaces.widget.SimpleObjectType("${componentInfo.dojoType}");
<%
}

boolean hasValidators = false;
String postBackHandler = "null";
if (context.componentInfo.isValueEditor){
    valuePropertyHandler = "org.dojoserverfaces.widget.property.ValueProperty";
    
    // Find the correct value property handler if a handler is defined.
    for(property in context.componentInfo.properties) {
        if(property.value) {
            if(property.handler != null) {
                valuePropertyHandler = property.handler;
            }
            property.getterName = "getNoValue";
            property.setterName = "setNoValue";
        }
        if (property.validator) {
            hasValidators = true;
        }
    }
    if (hasValidators) {
%>
    // List of attribute validators.
    
    private static final java.util.LinkedList<javax.faces.validator.Validator> validators =
        new java.util.LinkedList<javax.faces.validator.Validator>();
<%
    }%>    
    // The value property handler for this input component.
    private static final ${valuePropertyHandler} valueProperty = 
        new ${valuePropertyHandler}("value", "value");
<%
    postBackHandler = "valueProperty";
} 
else if (context.componentInfo.isActionSource){
%>    
    // The post back handler for this action component.
    private static final org.dojoserverfaces.widget.ActionPostBackHandler actionHandler =
        new org.dojoserverfaces.widget.ActionPostBackHandler();
<%
    postBackHandler = "actionHandler";
}
else if (context.componentInfo.postBackHandler != null){
%>    
    // The post back handler for this component.
    private static final ${context.componentInfo.postBackHandler} postBackHandler = 
        new ${context.componentInfo.postBackHandler}();
<%
    postBackHandler = "postBackHandler";
}
%>  
    static {
        // Initialize list of component property handlers used by renderer.
        org.dojoserverfaces.widget.property.Property _currentProperty;
<% 
String propertyGroups = "";
boolean namePropertyFound = false;
for(property in context.componentInfo.properties) {
    // We need to treat the value property handler special
    if(!property.value) {
        
        if(property.propertyName.equals("name")){
            // found a name property so do not add the default
            namePropertyFound = true;
        }
        %>
        _currentProperty = new ${property.handler}("${property.name}", "${property.propertyName}");
        <%
        if(property.group != null) { 
            // add this property to its group
            if(!propertyGroups.contains(property.group)){
                // create the complex property and add to component property list
                propertyGroups = propertyGroups + property.group;
%>
        org.dojoserverfaces.widget.property.ComplexProperty ${property.group}Property =
            new org.dojoserverfaces.widget.property.ComplexProperty("${property.group}");
        propertyHandlers.add(${property.group}Property);
<%
            }
%>
        ${property.group}Property.add(_currentProperty);
<%
        } else {
%>
        propertyHandlers.add(_currentProperty);
<%
        }
        
        if (hasValidators && property.validator) {
%>
        validators.add ((javax.faces.validator.Validator) _currentProperty);
<%
       }
    } // end not value property 
} // end for property

if (context.componentInfo.handlesPostBack && !namePropertyFound) {
%>
        // add the default name property handler
        propertyHandlers.add(new org.dojoserverfaces.widget.property.ClientIdProperty("name"));
<%
}
if (context.componentInfo.isValueEditor){
%>        
        // add the value property handler
        propertyHandlers.add(valueProperty);
<%
}%>
        // add in the event property handlers
<% 
for(event in context.componentInfo.events) { 
%>
        propertyHandlers.add(new ${event.handler}("${event.name}", "${event.eventName}"));
<% 
} // end for events
%>
        // Initialize static list of event names supported by this component.
<% 
for(event in context.componentInfo.events) { 
%>
        eventNames.add("${event.eventName}");
<% 
}
%>
    }
    
    /* (non-Javadoc)
    * @see javax.faces.component.UIComponentBase#getDefaultEventName()
    */
    @Override
    public java.lang.String getDefaultEventName() {
<%
if (null != context.componentInfo.defaultEvent) { %>        
        return "${context.componentInfo.defaultEvent.eventName}";
<%
} else { 
%>        return null;
<%
}
%>    }
    
    /* (non-Javadoc)
    * @see javax.faces.component.UIComponentBase#getEventNames()
    */
    @Override
    public java.util.Collection<java.lang.String> getEventNames() {
        return eventNames;
    }
    
    /* (non-Javadoc)
    * @see javax.faces.component.UIComponent#getFamily()
    */
    @Override
    public String getFamily() {
        return "${context.componentInfo.family}";
    }
    
    /* (non-Javadoc)
    * @see javax.faces.component.UIComponent#processEvent(javax.faces.event.ComponentSystemEvent)
    */
    @Override
    public void processEvent(javax.faces.event.ComponentSystemEvent event) throws javax.faces.event.AbortProcessingException {
        javax.faces.context.FacesContext context = javax.faces.context.FacesContext.getCurrentInstance();
        javax.faces.component.UIViewRoot view = context.getViewRoot();
        
        // rendered or not we are going to added these resources
        // this is because a subsequent ajax update may render the component
    
        // a ComponentResource is only added once(per jsf spec)
        // add in the dojo library resource
        org.dojoserverfaces.component.dojo.DojoLibraryComponent.addLibraryReferenceToView(view);
        
        // Make sure there is a script block on the view to which we'll add some script
        org.dojoserverfaces.component.dojo.DojoScriptBlockComponent.addScriptBlockToView(view);
<%
if (null != context.componentInfo.requiredCss && context.componentInfo.requiredCss.length > 0) {%>
        org.dojoserverfaces.component.dojo.DojoStyleComponent styleBlock = org.dojoserverfaces.component.dojo.DojoStyleComponent.findStyleBlockComponent(view);
<%
    for (String s : context.componentInfo.requiredCss){%>
        styleBlock.addRequiredCss("${s}");
<%
    }
}
if (!context.componentInfo.isWidget){ %> 
        /*
         * Move the dojo object component to the head. This takes it out of any parent
         * rendering sequence as it does not render any html markup. It will also insure
         * it is created before the widgets that may reference it.
         */
        view.addComponentResource(getFacesContext(), this, "head");
<%
}%>        
    }
    
    // DojoWidget methods.
    
    /* (non-Javadoc)
    * @see org.dojoserverfaces.component.dojo.DojoWidget#getElement()
    */
    @Override
    public org.dojoserverfaces.widget.element.HtmlElement getElement() {
        return element;
    }
    
    /* (non-Javadoc)
    * @see org.dojoserverfaces.component.dojo.DojoWidget#getPropertyHandlers()
    */
    @Override
    public java.util.Collection<org.dojoserverfaces.widget.property.Property> getPropertyHandlers() {
        return propertyHandlers;
    }
    
    /* (non-Javadoc)
    * @see org.dojoserverfaces.component.dojo.DojoWidget#getPostBackHandler()
    */
    @Override
    public org.dojoserverfaces.widget.PostBackHandler getPostBackHandler() {
        return ${postBackHandler};
    }

    /* (non-Javadoc)
    * @see org.dojoserverfaces.component.dojo.DojoWidget#getWidgetType()
    */
    @Override
    public org.dojoserverfaces.widget.DojoType getWidgetType() {
        return widgetType;
    }
    
    /* (non-Javadoc)
    * @see org.dojoserverfaces.component.dojo.DojoWidget#getJsfNode()
    */
    @Override
    public String getJsfNode() {
        return jsfNode;
    }
    
    /* (non-Javadoc)
     * @see org.dojoserverfaces.component.dojo.DojoWidget#getAttribute(java.lang.String)
     */
    @Override
    public Object getAttribute(String name) {
        return getStateHelper().eval(name, null);
    }

<% if (hasValidators) {
%>
    @Override
    protected void validateValue (javax.faces.context.FacesContext context, Object value) {
         // Add all validators, validate, then remove them.
         
         for (javax.faces.validator.Validator validator : validators) {
              addValidator (validator);
         }
                  
         super.validateValue (context, value);
         
         for (javax.faces.validator.Validator validator : validators) {
              removeValidator (validator);
         }
    }
<% } %>
    // Component property and event getters and setters.
<% 
for(property in context.componentInfo.properties) {
    if(property.comment == null) {
        getterComment = "Retrieves the value of the " + property.name + " property.";
        setterComment = "Sets the value of the " + property.name + " property.";
    } else {
        getterComment = property.comment;
        setterComment = property.comment;
    }
    // Make sure the getter/setter types for the value property are always Object.
    if(property.value) {
        propertyType = "java.lang.Object";
    } else {
        propertyType = property.type;
    }
    if(property.exposed) { 
%>
    /**
     * ${getterComment}
     *
     * @return a ${property.type} object containing the value of the ${property.name} property.
     */
    public ${propertyType} ${property.getterName}() {
        return(${propertyType}) getStateHelper().eval("${property.name}", null);
    }
    
    /**
     * ${setterComment}
     *
     * @param value a ${propertyType} object containing the new value to use.
     */
    public void ${property.setterName}(${propertyType} value) {
        getStateHelper().put("${property.name}", value);
    }
<%
    } 
} 
for(event in context.componentInfo.events) {
    if(event.comment == null) {
        getterComment = "Retrieves the value of the " + event.name + " event.";
        setterComment = "Sets the value of the " + event.name + " event.";
    } else {
        getterComment = event.comment;
        setterComment = event.comment;
    }
%>
         
    /**
     * ${getterComment}
     *
     * @return a ${event.type} object containing the value of the ${event.name} event.
     */
    public ${event.type} ${event.getterName}() {
        return(${event.type}) getStateHelper().eval("${event.name}", null);
    }
    
    /**
     * ${setterComment}
     *
     * @param value a ${event.type} object containing the new value to use.
     */
    public void ${event.setterName}(${event.type} value) {
        getStateHelper().put("${event.name}", value);
    }
<% 
}
%>
}
